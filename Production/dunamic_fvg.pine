//@version=6
indicator("Dynamic FVG", overlay=true, max_boxes_count=500, max_lines_count=500, max_labels_count=500, max_bars_back=5000)

blocksToShow = input.int(10, minval=0, title="转 拽 砖 专 爪", group="专转 转")
showCurrentFVG = input.bool(true, title="爪 FVG 转转 (3 专转 专)", group="专转 转")
minSizePercent = input.float(0.006, minval=0, title="   专", step=0.001, group="专转 转")

maxExtendBars = input.int(10, minval=0, title="拽住 专 专  (0= 专)", group="专转 专 ")
deleteOnFill = input.bool(false, title="拽  砖专 住 转", group="专转 专 ")
stopExtendOnFill = input.bool(true, title="注爪专 专转  砖专 住 转", group="专转 专 ")
gapBehavior = input.string("爪 ", title="转砖 -GAP  专转", options=["爪 ", "爪 专拽 FVG 注 GAP", "爪 专拽 FVG  GAP"], tooltip="GAP 专 砖专  驻驻  砖 专转 住.\n\n 爪 : 爪 转  -FVG  拽砖专 -GAP.\n\n 爪 专拽 FVG 注 GAP: 住 爪 专拽 FVG 砖砖  GAP  专转.\n\n 爪 专拽 FVG  GAP: 住 爪 专拽 FVG 砖  GAP  专转.", group="专转 专 ")

masterMethod = input.string("Pivot Points - 驻砖 拽转 驻 注 专转 砖 爪", title="砖转  转注 -MASTER-FVG", options=[" MASTER-FVG", "Pivot Points - 驻砖 拽转 驻 注 专转 砖 爪", "Local High/Low - 专 / 砖 ", "Swing High/Low - / 转专  专转 专"], tooltip=" Pivot Points: 拽 X 专转 驻 -X 专转 专. 砖    注 专 砖 X 专转. 专砖转 砖专 砖 .\n\n Local High/Low: 拽转 转 3 专转 - 专   2 专转 专.  专 砖 / 转专  砖砖 ( 专砖 ). 专   注 转专 false signals.  转 驻专专 '转 专转'.\n\n Swing High/Low: 驻砖转 转 / 转专  砖 X 专转 专.  专  驻转  -Pivot.", group="MASTER-FVG")
pivotBars = input.int(3, minval=2, title="转 专转  Pivot/Swing", group="MASTER-FVG")
maxFVGsInMove = input.int(3, minval=1, title="住驻专 FVG 拽住 转注", group="MASTER-FVG")
targetZonePercent = input.float(5, minval=0, maxval=100, title=" 专 注 (0=)", step=0.5, group="MASTER-FVG")
masterDeleteCondition = input.string("砖专 注 专 ", title="拽 MASTER-FVG 砖", options=["砖专 注 注", "砖专 注 专 "], tooltip=" 砖专 注 注: MASTER-FVG 拽 砖专 专 注 拽爪 注 (LONG)  转转 (SHORT).  爪转 专 .\n\n 砖专 注 专 : MASTER-FVG 拽 砖专 专 注 专 注 爪注. 专  爪 注  -MASTERs.", group="MASTER-FVG")
masterMaxToShow = input.int(5, minval=1, maxval=100, title="转 MASTER-FVG 爪 (100=)", tooltip=" MASTER-FVG 爪 注 住. 100 = 爪 转 .", group="MASTER-FVG")
targetZoneLongColor = input.color(color.new(color.green, 80), title="爪注 专 注 SHORT", group="MASTER-FVG")
targetZoneShortColor = input.color(color.new(color.red, 80), title="爪注 专 注 LONG", group="MASTER-FVG")

blockBorderWidth = input.int(1, minval=0, title="注   FVG (0=)", group="注爪 - 拽")
masterBorderWidth = input.int(2, minval=0, title="注  MASTER-FVG (0=)", group="注爪 - 拽")
middleLineWidth = input.int(1, minval=0, title="注 拽 爪注 (0=)", group="注爪 - 拽")
middleLineStyleStr = input.string("", title="住 拽 爪注", options=["", "拽拽", "拽转"], group="注爪 - 拽")

longBlockBorderColor = input.color(color.rgb(0, 255, 0), title="爪注   LONG", group="注爪 - 爪注 LONG")
longBlockBgColor = input.color(color.new(color.rgb(0, 255, 0), 90), title="爪注 专拽注  LONG", group="注爪 - 爪注 LONG")

shortBlockBorderColor = input.color(color.rgb(255, 0, 0), title="爪注   SHORT", group="注爪 - 爪注 SHORT")
shortBlockBgColor = input.color(color.new(color.rgb(255, 0, 0), 90), title="爪注 专拽注  SHORT", group="注爪 - 爪注 SHORT")

masterBlockBorderColor = input.color(color.rgb(0, 150, 255), title="爪注  MASTER-FVG ", group="注爪 - 爪注 MASTER-FVG")
masterBlockBgColor = input.color(color.new(color.rgb(0, 150, 255), 90), title="爪注 专拽注 MASTER-FVG ", group="注爪 - 爪注 MASTER-FVG")
oldMasterBorderColor = input.color(color.new(color.gray, 50), title="爪注  MASTER-FVG 砖", group="注爪 - 爪注 MASTER-FVG")
oldMasterBgColor = input.color(color.new(color.gray, 80), title="爪注 专拽注 MASTER-FVG 砖", group="注爪 - 爪注 MASTER-FVG")

showTargetZone = masterDeleteCondition == "砖专 注 专 "

getLineStyle(styleStr) =>
    styleStr == "拽拽" ? line.style_dashed : styleStr == "拽转" ? line.style_dotted : line.style_solid

lineStyle = getLineStyle(middleLineStyleStr)

isAboveMinSize(top, bottom, referencePrice) =>
    if minSizePercent == 0
        true
    else
        fvgSize = top - bottom
        minSize = referencePrice * (minSizePercent / 100)
        fvgSize >= minSize

hasGapBetweenCandles(idx1, idx2) =>
    low[idx2] > high[idx1] or high[idx2] < low[idx1]

passesGapFilter(offset) =>
    if gapBehavior == "爪 "
        true
    else
        hasGap1to2 = hasGapBetweenCandles(offset + 2, offset + 1)
        hasGap2to3 = hasGapBetweenCandles(offset + 1, offset)
        hasAnyGap = hasGap1to2 or hasGap2to3
        if gapBehavior == "爪 专拽 FVG 注 GAP"
            hasAnyGap
        else
            not hasAnyGap

var float lastPivotLow = na
var float lastPivotHigh = na
var int lastPivotLowBar = na
var int lastPivotHighBar = na

type PivotRecord
    int barIdx
    float price
    bool isHigh

type Block
    int barIndex
    float top
    float bottom
    bool isLong
    bool isFilled
    bool toShow
    bool shouldShow
    int fillBarIndex
    box theBox
    line theLine

type MasterFVG
    int pivotBar
    float pivotPrice
    float fvgMiddle
    int fvgBar
    bool isLong
    float masterTop
    float masterBottom
    float targetTop
    float targetBottom
    int rightBar
    bool isActive
    bool isCurrent
    box theBox
    line theLine
    box targetBox

var pivotHistory = array.new<PivotRecord>()
var blockList = array.new<Block>()
var array<int> activeFVGIndices = array.new<int>()
var masterFVGList = array.new<MasterFVG>()
var box currentLongBox = na
var line currentLongLine = na
var box currentShortBox = na
var line currentShortLine = na

isBlockLong = low[1] > high[3] and passesGapFilter(1)
isBlockShort = low[3] > high[1] and passesGapFilter(1)
isCurrentBlockLong = low > high[2] and passesGapFilter(0)
isCurrentBlockShort = low[2] > high and passesGapFilter(0)

if isBlockLong and isAboveMinSize(low[1], high[3], close[1])
    newIndex = array.size(blockList)
    array.push(blockList, Block.new(bar_index, low[1], high[3], true, false, true, false, na, na, na))
    array.push(activeFVGIndices, newIndex)

if isBlockShort and isAboveMinSize(low[3], high[1], close[1])
    newIndex = array.size(blockList)
    array.push(blockList, Block.new(bar_index, low[3], high[1], false, false, true, false, na, na, na))
    array.push(activeFVGIndices, newIndex)

if array.size(activeFVGIndices) > 0
    int toRemove = na
    for i = 0 to array.size(activeFVGIndices) - 1
        blockIndex = array.get(activeFVGIndices, i)
        if blockIndex >= 0 and blockIndex < array.size(blockList)
            block = array.get(blockList, blockIndex)
            if not block.isFilled
                if block.isLong
                    if low <= block.bottom
                        block.isFilled := true
                        block.fillBarIndex := bar_index
                        block.toShow := not deleteOnFill
                        array.set(blockList, blockIndex, block)
                        toRemove := i
                else
                    if high >= block.top
                        block.isFilled := true
                        block.fillBarIndex := bar_index
                        block.toShow := not deleteOnFill
                        array.set(blockList, blockIndex, block)
                        toRemove := i
    if not na(toRemove)
        array.remove(activeFVGIndices, toRemove)

if masterMethod != " MASTER-FVG"
    if masterMethod == "Pivot Points - 驻砖 拽转 驻 注 专转 砖 爪"
        pivotLowValue = ta.pivotlow(low, pivotBars, pivotBars)
        pivotHighValue = ta.pivothigh(high, pivotBars, pivotBars)
        if not na(pivotLowValue)
            lastPivotLow := pivotLowValue
            lastPivotLowBar := bar_index - pivotBars
            array.push(pivotHistory, PivotRecord.new(bar_index - pivotBars, pivotLowValue, false))
        if not na(pivotHighValue)
            lastPivotHigh := pivotHighValue
            lastPivotHighBar := bar_index - pivotBars
            array.push(pivotHistory, PivotRecord.new(bar_index - pivotBars, pivotHighValue, true))
    else if masterMethod == "Local High/Low - 专 / 砖 "
        isLocalLow = low < low[1] and low < low[2]
        isLocalHigh = high > high[1] and high > high[2]
        if isLocalLow
            lastPivotLow := low
            lastPivotLowBar := bar_index
            array.push(pivotHistory, PivotRecord.new(bar_index, low, false))
        if isLocalHigh
            lastPivotHigh := high
            lastPivotHighBar := bar_index
            array.push(pivotHistory, PivotRecord.new(bar_index, high, true))
    else if masterMethod == "Swing High/Low - / 转专  专转 专"
        isSwingLow = low == ta.lowest(low, pivotBars)
        isSwingHigh = high == ta.highest(high, pivotBars)
        if isSwingLow
            lastPivotLow := low
            lastPivotLowBar := bar_index
            array.push(pivotHistory, PivotRecord.new(bar_index, low, false))
        if isSwingHigh
            lastPivotHigh := high
            lastPivotHighBar := bar_index
            array.push(pivotHistory, PivotRecord.new(bar_index, high, true))
    
    maxPivotHistory = 200
    while array.size(pivotHistory) > maxPivotHistory
        array.shift(pivotHistory)

if barstate.islast
    var array<int> visibleIndices = array.new<int>()
    array.clear(visibleIndices)
    if array.size(blockList) > 0
        for i = 0 to array.size(blockList) - 1
            block = array.get(blockList, i)
            block.shouldShow := false
            if block.toShow
                array.push(visibleIndices, i)
            array.set(blockList, i, block)
    totalVisible = array.size(visibleIndices)
    startVisibleIndex = math.max(0, totalVisible - blocksToShow)
    if totalVisible > 0
        for j = startVisibleIndex to totalVisible - 1
            i = array.get(visibleIndices, j)
            block = array.get(blockList, i)
            block.shouldShow := true
            array.set(blockList, i, block)
    if array.size(blockList) > 0
        for i = 0 to array.size(blockList) - 1
            block = array.get(blockList, i)
            if block.shouldShow and na(block.theBox)
                leftBar = block.barIndex - 3
                rightBar = maxExtendBars > 0 ? math.min(block.barIndex - 1 + maxExtendBars, bar_index) : block.barIndex - 1
                if stopExtendOnFill and block.isFilled and not na(block.fillBarIndex)
                    rightBar := math.min(rightBar, block.fillBarIndex)
                middlePrice = (block.top + block.bottom) / 2
                if blockBorderWidth > 0
                    borderColor = block.isLong ? longBlockBorderColor : shortBlockBorderColor
                    bgColor = block.isLong ? longBlockBgColor : shortBlockBgColor
                    block.theBox := box.new(left=leftBar, top=block.top, right=rightBar, bottom=block.bottom, border_color=borderColor, border_width=blockBorderWidth, bgcolor=bgColor, extend=extend.none)
                    if middleLineWidth > 0
                        lineColor = block.isLong ? longBlockBorderColor : shortBlockBorderColor
                        block.theLine := line.new(x1=leftBar, y1=middlePrice, x2=rightBar, y2=middlePrice, color=lineColor, width=middleLineWidth, style=lineStyle)
                array.set(blockList, i, block)
            else if block.shouldShow and not na(block.theBox)
                rightBar = maxExtendBars > 0 ? math.min(block.barIndex - 1 + maxExtendBars, bar_index) : block.barIndex - 1
                if stopExtendOnFill and block.isFilled and not na(block.fillBarIndex)
                    rightBar := math.min(rightBar, block.fillBarIndex)
                box.set_right(block.theBox, rightBar)
                if not na(block.theLine)
                    line.set_x2(block.theLine, rightBar)
            else if not block.shouldShow and not na(block.theBox)
                box.delete(block.theBox)
                block.theBox := na
                if not na(block.theLine)
                    line.delete(block.theLine)
                    block.theLine := na
                array.set(blockList, i, block)
    
    if masterMethod != " MASTER-FVG" and array.size(pivotHistory) > 0
        if array.size(masterFVGList) > 0
            for i = 0 to array.size(masterFVGList) - 1
                master = array.get(masterFVGList, i)
                if not na(master.theBox)
                    box.delete(master.theBox)
                    master.theBox := na
                if not na(master.theLine)
                    line.delete(master.theLine)
                    master.theLine := na
                if not na(master.targetBox)
                    box.delete(master.targetBox)
                    master.targetBox := na
                array.set(masterFVGList, i, master)
        
        array.clear(masterFVGList)
        
        int maxPivotsToProcess = 100
        int pivotsToProcess = math.min(array.size(pivotHistory), maxPivotsToProcess)
        int startPivotIdx = array.size(pivotHistory) - pivotsToProcess
        
        for pIdx = startPivotIdx to array.size(pivotHistory) - 1
            pivot = array.get(pivotHistory, pIdx)
            
            if bar_index - pivot.barIdx > 2000
                continue
            
            int nextSamePivotBar = bar_index + 1
            bool foundSame = false
            if pIdx < array.size(pivotHistory) - 1
                for nextIdx = pIdx + 1 to array.size(pivotHistory) - 1
                    nextPivot = array.get(pivotHistory, nextIdx)
                    if nextPivot.isHigh == pivot.isHigh
                        nextSamePivotBar := nextPivot.barIdx
                        foundSame := true
                        break
            
            float targetFVGMiddle = na
            int targetFVGBar = na
            int fvgCount = 0
            
            if array.size(blockList) > 0
                for bIdx = 0 to array.size(blockList) - 1
                    block = array.get(blockList, bIdx)
                    if block.barIndex <= pivot.barIdx
                        continue
                    if block.barIndex > nextSamePivotBar
                        break
                    bool correctDirection = (not pivot.isHigh and block.isLong) or (pivot.isHigh and not block.isLong)
                    if correctDirection
                        fvgCount += 1
                        if fvgCount <= maxFVGsInMove
                            targetFVGMiddle := (block.top + block.bottom) / 2
                            targetFVGBar := block.barIndex
            
            if not na(targetFVGMiddle)
                float mTop = na
                float mBottom = na
                float mHeight = 0.0
                bool mIsLong = not pivot.isHigh
                
                if mIsLong
                    mHeight := (targetFVGMiddle - pivot.price) * 2
                    mTop := pivot.price + mHeight
                    mBottom := pivot.price
                else
                    mHeight := (pivot.price - targetFVGMiddle) * 2
                    mTop := pivot.price
                    mBottom := pivot.price - mHeight
                
                float tgtTop = na
                float tgtBottom = na
                if targetZonePercent > 0
                    targetZoneHeight = mHeight * (targetZonePercent / 100)
                    if mIsLong
                        tgtTop := mTop
                        tgtBottom := mTop - targetZoneHeight
                    else
                        tgtTop := mBottom + targetZoneHeight
                        tgtBottom := mBottom
                
                int mRightBar = foundSame ? nextSamePivotBar : bar_index
                
                bool isActive = true
                bool isLastMove = not foundSame
                
                if not isLastMove
                    int checkStartBar = math.max(pivot.barIdx + 1, bar_index - 500)
                    int checkEndBar = bar_index
                    
                    if masterDeleteCondition == "砖专 注 注"
                        if mIsLong
                            for checkBar = checkStartBar to checkEndBar
                                offset = bar_index - checkBar
                                if offset >= 0 and high[offset] >= mTop
                                    isActive := false
                                    break
                        else
                            for checkBar = checkStartBar to checkEndBar
                                offset = bar_index - checkBar
                                if offset >= 0 and low[offset] <= mBottom
                                    isActive := false
                                    break
                    else
                        targetLevel = mIsLong ? (targetZonePercent > 0 ? tgtBottom : mTop) : (targetZonePercent > 0 ? tgtTop : mBottom)
                        if mIsLong
                            for checkBar = checkStartBar to checkEndBar
                                offset = bar_index - checkBar
                                if offset >= 0 and high[offset] >= targetLevel
                                    isActive := false
                                    break
                        else
                            for checkBar = checkStartBar to checkEndBar
                                offset = bar_index - checkBar
                                if offset >= 0 and low[offset] <= targetLevel
                                    isActive := false
                                    break
                
                newMaster = MasterFVG.new(pivot.barIdx, pivot.price, targetFVGMiddle, targetFVGBar, mIsLong, mTop, mBottom, tgtTop, tgtBottom, mRightBar, isActive, false, na, na, na)
                array.push(masterFVGList, newMaster)
        
        if array.size(masterFVGList) > 0
            lastMasterIdx = array.size(masterFVGList) - 1
            lastMaster = array.get(masterFVGList, lastMasterIdx)
            lastMaster.isCurrent := true
            lastMaster.rightBar := bar_index
            array.set(masterFVGList, lastMasterIdx, lastMaster)
        
        var array<int> activeIndices = array.new<int>()
        array.clear(activeIndices)
        if array.size(masterFVGList) > 0
            for i = 0 to array.size(masterFVGList) - 1
                master = array.get(masterFVGList, i)
                if master.isActive
                    array.push(activeIndices, i)
        
        int totalActive = array.size(activeIndices)
        int startIdx = math.max(0, totalActive - masterMaxToShow)
        
        if totalActive > 0
            for j = startIdx to totalActive - 1
                i = array.get(activeIndices, j)
                master = array.get(masterFVGList, i)
                
                int drawLeftBar = master.pivotBar
                int drawRightBar = master.isCurrent ? bar_index : master.rightBar
                float masterMiddle = (master.masterTop + master.masterBottom) / 2
                
                if master.isCurrent
                    if masterBorderWidth > 0
                        master.theBox := box.new(left=drawLeftBar, top=master.masterTop, right=drawRightBar, bottom=master.masterBottom, border_color=masterBlockBorderColor, border_width=masterBorderWidth, bgcolor=masterBlockBgColor, extend=extend.none)
                        if middleLineWidth > 0
                            master.theLine := line.new(x1=drawLeftBar, y1=masterMiddle, x2=drawRightBar, y2=masterMiddle, color=masterBlockBorderColor, width=middleLineWidth, style=lineStyle)
                    if showTargetZone and targetZonePercent > 0 and not na(master.targetTop)
                        targetColor = master.isLong ? targetZoneShortColor : targetZoneLongColor
                        master.targetBox := box.new(left=drawLeftBar, top=master.targetTop, right=drawRightBar, bottom=master.targetBottom, border_color=color.new(color.white, 100), border_width=0, bgcolor=targetColor, extend=extend.none)
                else
                    master.theBox := box.new(left=drawLeftBar, top=master.masterTop, right=drawRightBar, bottom=master.masterBottom, border_color=oldMasterBorderColor, border_width=masterBorderWidth, bgcolor=oldMasterBgColor, extend=extend.none)
                    if middleLineWidth > 0
                        master.theLine := line.new(x1=drawLeftBar, y1=masterMiddle, x2=drawRightBar, y2=masterMiddle, color=oldMasterBorderColor, width=middleLineWidth, style=lineStyle)
                    if showTargetZone and targetZonePercent > 0 and not na(master.targetTop)
                        targetColor = master.isLong ? targetZoneShortColor : targetZoneLongColor
                        master.targetBox := box.new(left=drawLeftBar, top=master.targetTop, right=drawRightBar, bottom=master.targetBottom, border_color=color.new(color.white, 100), border_width=0, bgcolor=targetColor, extend=extend.none)
                
                array.set(masterFVGList, i, master)
    
    if showCurrentFVG
        if isCurrentBlockLong and isAboveMinSize(low, high[2], close)
            currentLongMiddle = (low + high[2]) / 2
            currentRightBar = maxExtendBars > 0 ? math.min(bar_index - 2 + maxExtendBars, bar_index) : bar_index
            if blockBorderWidth > 0
                if na(currentLongBox)
                    currentLongBox := box.new(left=bar_index - 2, top=low, right=currentRightBar, bottom=high[2], border_color=longBlockBorderColor, border_width=blockBorderWidth, bgcolor=longBlockBgColor, extend=extend.none)
                    if middleLineWidth > 0
                        currentLongLine := line.new(x1=bar_index - 2, y1=currentLongMiddle, x2=currentRightBar, y2=currentLongMiddle, color=longBlockBorderColor, width=middleLineWidth, style=lineStyle)
                else
                    box.set_lefttop(currentLongBox, bar_index - 2, low)
                    box.set_rightbottom(currentLongBox, currentRightBar, high[2])
                    if not na(currentLongLine)
                        line.set_xy1(currentLongLine, bar_index - 2, currentLongMiddle)
                        line.set_xy2(currentLongLine, currentRightBar, currentLongMiddle)
        else
            if not na(currentLongBox)
                box.delete(currentLongBox)
                currentLongBox := na
            if not na(currentLongLine)
                line.delete(currentLongLine)
                currentLongLine := na
        if isCurrentBlockShort and isAboveMinSize(low[2], high, close)
            currentShortMiddle = (low[2] + high) / 2
            currentRightBar = maxExtendBars > 0 ? math.min(bar_index - 2 + maxExtendBars, bar_index) : bar_index
            if blockBorderWidth > 0
                if na(currentShortBox)
                    currentShortBox := box.new(left=bar_index - 2, top=low[2], right=currentRightBar, bottom=high, border_color=shortBlockBorderColor, border_width=blockBorderWidth, bgcolor=shortBlockBgColor, extend=extend.none)
                    if middleLineWidth > 0
                        currentShortLine := line.new(x1=bar_index - 2, y1=currentShortMiddle, x2=currentRightBar, y2=currentShortMiddle, color=shortBlockBorderColor, width=middleLineWidth, style=lineStyle)
                else
                    box.set_lefttop(currentShortBox, bar_index - 2, low[2])
                    box.set_rightbottom(currentShortBox, currentRightBar, high)
                    if not na(currentShortLine)
                        line.set_xy1(currentShortLine, bar_index - 2, currentShortMiddle)
                        line.set_xy2(currentShortLine, currentRightBar, currentShortMiddle)
        else
            if not na(currentShortBox)
                box.delete(currentShortBox)
                currentShortBox := na
            if not na(currentShortLine)
                line.delete(currentShortLine)
                currentShortLine := na
